"""dslmodel REST API with SSE for OpenAI responses."""

import asyncio
import logging
from time import perf_counter
from typing import AsyncGenerator, AsyncIterable

import coloredlogs
from fastapi import FastAPI, APIRouter, Request
from fastapi.middleware.cors import CORSMiddleware
from openai import AsyncOpenAI
from starlette.responses import StreamingResponse

# Configuration constants
MESSAGE_STREAM_RETRY_TIMEOUT_MS = 15000  # milliseconds
STREAMING_MODEL = 'gpt-4o-mini'  # OpenAI model to use

# Initialize logging with colored output
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
coloredlogs.install(level='INFO', logger=logger)


async def lifespan_handler(app: FastAPI) -> AsyncGenerator[None, None]:
    """Handle FastAPI startup and shutdown events."""
    logger.info("Starting up FastAPI application...")

    # Clean up and set up logging
    for handler in logging.root.handlers:
        logging.root.removeHandler(handler)
    coloredlogs.install()

    yield  # Startup complete; hand control back to FastAPI

    logger.info("Shutting down FastAPI application...")


# FastAPI app setup
app = FastAPI(lifespan=lifespan_handler)

# CORS middleware to allow frontend access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Adjust origins as needed in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# API router
router = APIRouter()

"""dslmodel REST API with WebSocket for OpenAI responses."""

import asyncio
import logging
from typing import List

import coloredlogs
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from openai import AsyncOpenAI

# Configuration constants
STREAMING_MODEL = 'gpt-4o-mini'  # OpenAI model to use

# Initialize logging with colored output
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
coloredlogs.install(level='INFO', logger=logger)


# Connection manager for handling multiple WebSocket clients
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        """Send a message to all connected clients."""
        for connection in self.active_connections:
            await connection.send_text(message)


manager = ConnectionManager()


async def openai_response_generator() -> str:
    """Generates responses from the OpenAI API for streaming via WebSocket."""
    logger.debug("Starting OpenAI response generator...")

    messages = [
        {'role': 'system', 'content': 'You are a helpful assistant.'},
        {'role': 'user', 'content': 'What is SSE? Please include a JavaScript code example.'}
    ]

    try:
        async with AsyncOpenAI() as openai:
            # Stream the response from OpenAI's API
            chunks = await openai.chat.completions.create(
                model=STREAMING_MODEL,
                messages=messages,
                stream=True
            )

            async for chunk in chunks:
                text = chunk.choices[0].delta.content if chunk.choices and chunk.choices[0].delta else ''
                if text:
                    logger.debug(f"Streaming chunk: {text[:30]}...")  # Log a snippet of the chunk for traceability
                    yield text

    except Exception as e:
        logger.error("Error in OpenAI response generator: %s", str(e))
        yield f"Error occurred - {str(e)}"


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for streaming OpenAI responses."""
    await manager.connect(websocket)
    logger.info("New WebSocket connection established.")

    try:
        # Send messages to the client as they are generated by OpenAI
        async for message in openai_response_generator():
            await manager.broadcast(message)

    except WebSocketDisconnect:
        manager.disconnect(websocket)
        logger.info("WebSocket connection closed.")


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="127.0.0.1", port=8000)
