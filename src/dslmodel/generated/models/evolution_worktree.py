"""
Evolution_worktree - Auto-generated from semantic convention
Generated by WeaverEngine - DO NOT EDIT MANUALLY
"""

from typing import Optional, List, Literal, Dict, Any
from pydantic import Field
from opentelemetry import trace
from dslmodel import DSLModel


class Evolution_worktree_experiment(DSLModel):
    """Evolution experiment in isolated worktree"""
    
    experiment_id: str = Field(
...,
        description="Unique identifier for the evolution experiment"
, examples=['exp-001', 'evolution-2024-001', 'candidate-12345']    )
    worktree_path: str = Field(
...,
        description="Path to the isolated worktree for this experiment"
, examples=['/worktrees/evolution_exp_001', '/worktrees/candidate_perf_opt']    )
    branch_name: str = Field(
...,
        description="Git branch for the evolution experiment"
, examples=['evolution/exp-001', 'candidate/perf-optimization', 'experiment/feature-enhancement']    )
    base_commit: str = Field(
...,
        description="Base commit SHA from which evolution started"
    )
    evolution_strategy: str = Field(
...,
        description="Strategy used for this evolution experiment"
, examples=['performance', 'security', 'features', 'quality', 'architecture']    )
    fitness_before: Optional[float] = Field(
        None,
        description="System fitness score before evolution"
    )
    target_fitness: Optional[float] = Field(
        None,
        description="Target fitness score for this experiment"
    )
    generation_number: Optional[int] = Field(
        None,
        description="Generation number in evolution cycle"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("evolution.worktree.experiment") as span:
            if self.experiment_id is not None:
                span.set_attribute("evolution.worktree.experiment.experiment_id", self.experiment_id)
            if self.worktree_path is not None:
                span.set_attribute("evolution.worktree.experiment.worktree_path", self.worktree_path)
            if self.branch_name is not None:
                span.set_attribute("evolution.worktree.experiment.branch_name", self.branch_name)
            if self.base_commit is not None:
                span.set_attribute("evolution.worktree.experiment.base_commit", self.base_commit)
            if self.evolution_strategy is not None:
                span.set_attribute("evolution.worktree.experiment.evolution_strategy", self.evolution_strategy)
            if self.fitness_before is not None:
                span.set_attribute("evolution.worktree.experiment.fitness_before", self.fitness_before)
            if self.target_fitness is not None:
                span.set_attribute("evolution.worktree.experiment.target_fitness", self.target_fitness)
            if self.generation_number is not None:
                span.set_attribute("evolution.worktree.experiment.generation_number", self.generation_number)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Evolution_worktree_mutation(DSLModel):
    """Code mutation applied in worktree"""
    
    experiment_id: str = Field(
...,
        description="Associated evolution experiment"
    )
    mutation_id: str = Field(
...,
        description="Unique identifier for this mutation"
    )
    mutation_type: str = Field(
...,
        description="Type of mutation being applied"
, examples=['refactor', 'optimize', 'parallelize', 'cache_add', 'algorithm_change']    )
    target_file: str = Field(
...,
        description="File being mutated"
    )
    target_function: Optional[str] = None = Field(
None,
        description="Function or class being mutated"
    )
    mutation_description: Optional[str] = None = Field(
None,
        description="Human-readable description of the mutation"
    )
    risk_level: Optional[str] = None = Field(
None,
        description="Risk level of the mutation"
, examples=['low', 'medium', 'high', 'critical']    )
    rollback_capable: Optional[bool] = None = Field(
None,
        description="Whether mutation can be rolled back"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("evolution.worktree.mutation") as span:
            if self.experiment_id is not None:
                span.set_attribute("evolution.worktree.mutation.experiment_id", self.experiment_id)
            if self.mutation_id is not None:
                span.set_attribute("evolution.worktree.mutation.mutation_id", self.mutation_id)
            if self.mutation_type is not None:
                span.set_attribute("evolution.worktree.mutation.mutation_type", self.mutation_type)
            if self.target_file is not None:
                span.set_attribute("evolution.worktree.mutation.target_file", self.target_file)
            if self.target_function is not None:
                span.set_attribute("evolution.worktree.mutation.target_function", self.target_function)
            if self.mutation_description is not None:
                span.set_attribute("evolution.worktree.mutation.mutation_description", self.mutation_description)
            if self.risk_level is not None:
                span.set_attribute("evolution.worktree.mutation.risk_level", self.risk_level)
            if self.rollback_capable is not None:
                span.set_attribute("evolution.worktree.mutation.rollback_capable", self.rollback_capable)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Evolution_worktree_validation(DSLModel):
    """Validation of evolution changes in worktree"""
    
    experiment_id: str = Field(
...,
        description="Evolution experiment being validated"
    )
    worktree_path: str = Field(
...,
        description="Worktree containing changes to validate"
    )
    validation_type: str = Field(
...,
        description="Type of validation being performed"
, examples=['unit_tests', 'integration_tests', 'performance_tests', 'security_scan', 'fitness_evaluation']    )
    tests_total: Optional[int] = Field(
        None,
        description="Total number of tests executed"
    )
    tests_passed: Optional[int] = Field(
        None,
        description="Number of tests that passed"
    )
    fitness_score: Optional[float] = Field(
        None,
        description="Measured fitness score after changes"
    )
    performance_impact: Optional[float] = Field(
        None,
        description="Performance impact percentage"
    )
    validation_passed: bool = Field(
...,
        description="Whether validation passed overall"
    )
    blocking_issues: Optional[int] = Field(
        None,
        description="Number of blocking issues found"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("evolution.worktree.validation") as span:
            if self.experiment_id is not None:
                span.set_attribute("evolution.worktree.validation.experiment_id", self.experiment_id)
            if self.worktree_path is not None:
                span.set_attribute("evolution.worktree.validation.worktree_path", self.worktree_path)
            if self.validation_type is not None:
                span.set_attribute("evolution.worktree.validation.validation_type", self.validation_type)
            if self.tests_total is not None:
                span.set_attribute("evolution.worktree.validation.tests_total", self.tests_total)
            if self.tests_passed is not None:
                span.set_attribute("evolution.worktree.validation.tests_passed", self.tests_passed)
            if self.fitness_score is not None:
                span.set_attribute("evolution.worktree.validation.fitness_score", self.fitness_score)
            if self.performance_impact is not None:
                span.set_attribute("evolution.worktree.validation.performance_impact", self.performance_impact)
            if self.validation_passed is not None:
                span.set_attribute("evolution.worktree.validation.validation_passed", self.validation_passed)
            if self.blocking_issues is not None:
                span.set_attribute("evolution.worktree.validation.blocking_issues", self.blocking_issues)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Evolution_worktree_merge(DSLModel):
    """Merge successful evolution back to main branch"""
    
    experiment_id: str = Field(
...,
        description="Evolution experiment being merged"
    )
    source_worktree: str = Field(
...,
        description="Source worktree path"
    )
    source_branch: str = Field(
...,
        description="Branch being merged"
    )
    target_branch: str = Field(
...,
        description="Target branch for merge"
, examples=['main', 'develop', 'evolution/stable']    )
    fitness_improvement: float = Field(
        ...,
        description="Fitness improvement achieved"
    )
    mutations_merged: Optional[int] = Field(
        None,
        description="Number of mutations being merged"
    )
    pr_number: Optional[str] = Field(
        None,
        description="Pull request number if applicable"
    )
    merge_strategy: Optional[str] = Field(
        None,
        description="Strategy used for merging",
        examples=['merge', 'squash', 'rebase']
    )
    rollback_plan: Optional[str] = Field(
        None,
        description="Rollback plan if issues arise"
    )
    merge_success: bool = Field(
...,
        description="Whether merge completed successfully"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("evolution.worktree.merge") as span:
            if self.experiment_id is not None:
                span.set_attribute("evolution.worktree.merge.experiment_id", self.experiment_id)
            if self.source_worktree is not None:
                span.set_attribute("evolution.worktree.merge.source_worktree", self.source_worktree)
            if self.source_branch is not None:
                span.set_attribute("evolution.worktree.merge.source_branch", self.source_branch)
            if self.target_branch is not None:
                span.set_attribute("evolution.worktree.merge.target_branch", self.target_branch)
            if self.fitness_improvement is not None:
                span.set_attribute("evolution.worktree.merge.fitness_improvement", self.fitness_improvement)
            if self.mutations_merged is not None:
                span.set_attribute("evolution.worktree.merge.mutations_merged", self.mutations_merged)
            if self.pr_number is not None:
                span.set_attribute("evolution.worktree.merge.pr_number", self.pr_number)
            if self.merge_strategy is not None:
                span.set_attribute("evolution.worktree.merge.merge_strategy", self.merge_strategy)
            if self.rollback_plan is not None:
                span.set_attribute("evolution.worktree.merge.rollback_plan", self.rollback_plan)
            if self.merge_success is not None:
                span.set_attribute("evolution.worktree.merge.merge_success", self.merge_success)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Evolution_worktree_monitoring(DSLModel):
    """Monitor deployed evolution in production"""
    
    experiment_id: str = Field(
...,
        description="Original evolution experiment"
    )
    deployment_id: str = Field(
...,
        description="Deployment identifier"
    )
    monitoring_duration_ms: int = Field(
...,
        description="Duration of monitoring period"
    )
    fitness_trend: Optional[str] = Field(
        None,
        description="Trend in fitness metrics",
        examples=['improving', 'stable', 'degrading', 'volatile']
    )
    performance_metrics: Optional[str] = Field(
        None,
        description="JSON string of performance metrics"
    )
    error_rate: Optional[float] = Field(
        None,
        description="Error rate percentage"
    )
    rollback_triggered: Optional[bool] = Field(
        None,
        description="Whether rollback was triggered"
    )
    user_impact: Optional[str] = Field(
        None,
        description="Impact on users",
        examples=['positive', 'neutral', 'negative', 'none']
    )
    learning_captured: Optional[bool] = Field(
        None,
        description="Whether learnings were captured for future evolution"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("evolution.worktree.monitoring") as span:
            if self.experiment_id is not None:
                span.set_attribute("evolution.worktree.monitoring.experiment_id", self.experiment_id)
            if self.deployment_id is not None:
                span.set_attribute("evolution.worktree.monitoring.deployment_id", self.deployment_id)
            if self.monitoring_duration_ms is not None:
                span.set_attribute("evolution.worktree.monitoring.monitoring_duration_ms", self.monitoring_duration_ms)
            if self.fitness_trend is not None:
                span.set_attribute("evolution.worktree.monitoring.fitness_trend", self.fitness_trend)
            if self.performance_metrics is not None:
                span.set_attribute("evolution.worktree.monitoring.performance_metrics", self.performance_metrics)
            if self.error_rate is not None:
                span.set_attribute("evolution.worktree.monitoring.error_rate", self.error_rate)
            if self.rollback_triggered is not None:
                span.set_attribute("evolution.worktree.monitoring.rollback_triggered", self.rollback_triggered)
            if self.user_impact is not None:
                span.set_attribute("evolution.worktree.monitoring.user_impact", self.user_impact)
            if self.learning_captured is not None:
                span.set_attribute("evolution.worktree.monitoring.learning_captured", self.learning_captured)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Evolution_worktree_coordination(DSLModel):
    """SwarmAgent coordination of evolution worktrees"""
    
    agent_id: str = Field(
...,
        description="SwarmAgent coordinating evolution"
, examples=['evolution-agent-001', 'darwin-bot', 'fitness-optimizer']    )
    coordination_action: str = Field(
...,
        description="Coordination action being performed"
, examples=['assign_experiment', 'evaluate_fitness', 'select_candidates', 'merge_improvements']    )
    active_experiments: Optional[int] = Field(
        None,
        description="Number of active evolution experiments"
    )
    worktrees_managed: Optional[int] = Field(
        None,
        description="Number of worktrees being managed"
    )
    fitness_baseline: Optional[float] = Field(
        None,
        description="Current system fitness baseline"
    )
    improvement_target: Optional[float] = Field(
        None,
        description="Target improvement percentage"
    )
    strategy_distribution: Optional[str] = Field(
        None,
        description="JSON string of strategy distribution across experiments"
    )
    convergence_detected: Optional[bool] = Field(
        None,
        description="Whether evolution convergence was detected"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("evolution.worktree.coordination") as span:
            if self.agent_id is not None:
                span.set_attribute("evolution.worktree.coordination.agent_id", self.agent_id)
            if self.coordination_action is not None:
                span.set_attribute("evolution.worktree.coordination.coordination_action", self.coordination_action)
            if self.active_experiments is not None:
                span.set_attribute("evolution.worktree.coordination.active_experiments", self.active_experiments)
            if self.worktrees_managed is not None:
                span.set_attribute("evolution.worktree.coordination.worktrees_managed", self.worktrees_managed)
            if self.fitness_baseline is not None:
                span.set_attribute("evolution.worktree.coordination.fitness_baseline", self.fitness_baseline)
            if self.improvement_target is not None:
                span.set_attribute("evolution.worktree.coordination.improvement_target", self.improvement_target)
            if self.strategy_distribution is not None:
                span.set_attribute("evolution.worktree.coordination.strategy_distribution", self.strategy_distribution)
            if self.convergence_detected is not None:
                span.set_attribute("evolution.worktree.coordination.convergence_detected", self.convergence_detected)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
