"""
FSM-Weaver Integration Module

Combines FSMMixin state machines with OpenTelemetry semantic conventions
generated by Weaver Forge for observable workflow execution.
"""
from typing import Optional, Type, Dict, Any, List
from enum import Enum
from pathlib import Path
import functools
from loguru import logger

from pydantic import Field, BaseModel
from opentelemetry import trace, metrics
from opentelemetry.trace import Status, StatusCode

from dslmodel.dsl_models import DSLModel
from dslmodel.mixins.fsm_mixin import FSMMixin, trigger
from dslmodel.otel.weaver_integration import WeaverForgeIntegration


class ObservableFSMMixin(FSMMixin):
    """
    Enhanced FSMMixin that automatically instruments state transitions
    with OpenTelemetry spans and metrics.
    """
    
    _tracer: Optional[trace.Tracer] = None
    _meter: Optional[metrics.Meter] = None
    _state_duration_histogram: Optional[metrics.Histogram] = None
    
    def setup_observability(
        self, 
        service_name: str = "dslmodel-fsm",
        meter_name: Optional[str] = None
    ):
        """Initialize OpenTelemetry instrumentation for the FSM."""
        # Get tracer and meter
        self._tracer = trace.get_tracer(service_name)
        self._meter = metrics.get_meter(meter_name or service_name)
        
        # Create metrics
        self._state_duration_histogram = self._meter.create_histogram(
            name="fsm.state.duration",
            description="Duration spent in each state",
            unit="ms"
        )
        
        self._transition_counter = self._meter.create_counter(
            name="fsm.transitions.total", 
            description="Total number of state transitions"
        )
        
    def add_transition(self, *args, **kwargs):
        """Override to wrap transitions with observability."""
        # Get the original before/after callbacks
        original_before = kwargs.get('before', [])
        original_after = kwargs.get('after', [])
        
        # Ensure they are lists
        if not isinstance(original_before, list):
            original_before = [original_before] if original_before else []
        if not isinstance(original_after, list):
            original_after = [original_after] if original_after else []
            
        # Add observability callbacks
        kwargs['before'] = ['_start_transition_span'] + original_before
        kwargs['after'] = original_after + ['_end_transition_span']
        
        super().add_transition(*args, **kwargs)
        
    def _start_transition_span(self):
        """Start a span for the transition."""
        if not self._tracer:
            return
            
        # Get transition info from current context
        transition = self.machine.get_transitions(
            trigger=self.machine._process.trigger.name,
            source=self.state,
            dest=self.machine._process.target
        )[0]
        
        # Start span
        span = self._tracer.start_span(
            f"fsm.transition.{transition.trigger}",
            attributes={
                "fsm.transition.trigger": transition.trigger,
                "fsm.transition.source": transition.source, 
                "fsm.transition.dest": transition.dest,
                "fsm.model.type": self.__class__.__name__
            }
        )
        
        # Store span for later
        self._current_span = span
        self._transition_start_time = trace.get_current_span().start_time
        
    def _end_transition_span(self):
        """End the transition span and record metrics."""
        if not hasattr(self, '_current_span'):
            return
            
        span = self._current_span
        
        # Record success
        span.set_status(Status(StatusCode.OK))
        span.end()
        
        # Record metrics
        if self._transition_counter:
            self._transition_counter.add(
                1,
                attributes={
                    "source_state": self.machine._process.source,
                    "dest_state": self.state
                }
            )
        
        # Clean up
        delattr(self, '_current_span')


class WeaverFSMModel(DSLModel, ObservableFSMMixin):
    """
    Base class combining DSLModel with observable FSM capabilities.
    Models generated by Weaver can inherit from this to get both
    type-safe OTEL attributes and state machine functionality.
    """
    
    def __init__(self, **data):
        DSLModel.__init__(self, **data)
        ObservableFSMMixin.__init__(self)
        
    def model_post_init(self, __context: Any) -> None:
        """Initialize FSM after model creation."""
        super().model_post_init(__context)
        
        # Auto-setup observability if OTEL is configured
        if trace.get_tracer_provider():
            self.setup_observability(
                service_name=f"dslmodel.{self.__class__.__name__.lower()}"
            )


class WorkflowStateGenerator:
    """
    Generates semantic conventions and FSM-enabled models for workflows.
    """
    
    def __init__(self, weaver_integration: Optional[WeaverForgeIntegration] = None):
        self.weaver = weaver_integration or WeaverForgeIntegration()
        
    def create_workflow_semconv(
        self,
        workflow_name: str,
        states: List[str],
        attributes: Optional[Dict[str, Any]] = None
    ) -> Path:
        """
        Create semantic conventions for a workflow with FSM states.
        
        Args:
            workflow_name: Name of the workflow
            states: List of valid states for the FSM
            attributes: Additional attributes to include
            
        Returns:
            Path to generated semconv YAML file
        """
        registry_dir = self.weaver.project_root / "semconv_registry" / "workflows"
        registry_dir.mkdir(parents=True, exist_ok=True)
        
        semconv_path = registry_dir / f"{workflow_name}.yaml"
        
        # Build state enum members
        state_members = [
            {
                "id": state.lower().replace(" ", "_"),
                "value": state
            }
            for state in states
        ]
        
        # Base content
        content = {
            "groups": [{
                "id": f"{workflow_name}_workflow",
                "prefix": workflow_name.lower(),
                "type": "attribute_group",
                "brief": f"Attributes for {workflow_name} workflow execution",
                "attributes": [
                    {
                        "id": "state",
                        "type": {
                            "allow_custom_values": False,
                            "members": state_members
                        },
                        "requirement_level": "required",
                        "brief": f"Current state of the {workflow_name} workflow"
                    },
                    {
                        "id": "transition.count",
                        "type": "int", 
                        "requirement_level": "recommended",
                        "brief": "Number of state transitions"
                    },
                    {
                        "id": "duration_ms",
                        "type": "int",
                        "requirement_level": "recommended", 
                        "brief": "Total workflow duration in milliseconds"
                    }
                ]
            }]
        }
        
        # Add custom attributes
        if attributes:
            for attr_name, attr_config in attributes.items():
                content["groups"][0]["attributes"].append({
                    "id": attr_name,
                    **attr_config
                })
        
        # Write YAML
        import yaml
        semconv_path.write_text(yaml.dump(content, default_flow_style=False))
        
        logger.info(f"Created workflow semconv at {semconv_path}")
        return semconv_path
        
    def generate_fsm_model(
        self,
        workflow_name: str,
        states: List[str],
        transitions: List[Dict[str, Any]],
        attributes: Optional[Dict[str, Any]] = None
    ) -> bool:
        """
        Generate a complete FSM-enabled model from workflow definition.
        
        Args:
            workflow_name: Name of the workflow
            states: List of valid states
            transitions: List of transition definitions
            attributes: Additional attributes for the model
            
        Returns:
            True if generation succeeded
        """
        # Create semantic conventions
        semconv_path = self.create_workflow_semconv(
            workflow_name, states, attributes
        )
        
        # Ensure we have FSM-aware templates
        self._ensure_fsm_templates()
        
        # Generate models using Weaver
        success = self.weaver.generate_models(
            str(semconv_path.parent),
            target="python",
            output_dir=str(self.weaver.project_root / "output" / "workflows")
        )
        
        if success:
            # Post-process to add FSM setup
            self._add_fsm_setup(workflow_name, states, transitions)
            
        return success
        
    def _ensure_fsm_templates(self):
        """Ensure we have templates that generate FSM-aware models."""
        template_dir = self.weaver.templates_dir / "registry" / "python"
        template_dir.mkdir(parents=True, exist_ok=True)
        
        # Create FSM-aware Pydantic model template
        fsm_template = template_dir / "fsm_pydantic_model.j2"
        fsm_template.write_text("""
{%- macro render_field(field) -%}
    {{ field.id }}: {{ field.type | python_type }}
    {%- if field.brief %} = Field(description="{{ field.brief }}"){% endif %}
{%- endmacro -%}

\"\"\"
Generated {{ group.id }} FSM Model
{{ group.brief }}
\"\"\"
from typing import Optional
from enum import Enum
from pydantic import Field

from dslmodel.otel.fsm_weaver_integration import WeaverFSMModel, trigger


class {{ group.id | pascal_case }}State(str, Enum):
    \"\"\"States for {{ group.id }} workflow.\"\"\"
    {%- for member in group.attributes[0].type.members %}
    {{ member.id | upper }} = "{{ member.value }}"
    {%- endfor %}


class {{ group.id | pascal_case }}Model(WeaverFSMModel):
    \"\"\"
    {{ group.brief }}
    
    This model includes FSM capabilities for workflow state management.
    \"\"\"
    
    {%- for attr in group.attributes %}
    {{ render_field(attr) }}
    {%- endfor %}
    
    def model_post_init(self, __context) -> None:
        \"\"\"Initialize the FSM after model creation.\"\"\"
        super().model_post_init(__context)
        
        # Setup FSM with workflow states
        self.setup_fsm({{ group.id | pascal_case }}State, initial={{ group.id | pascal_case }}State.{{ group.attributes[0].type.members[0].id | upper }})
        
        # Setup observability
        self.setup_observability(service_name="{{ group.id }}")
""")
        
        logger.info("Created FSM-aware template")
        
    def _add_fsm_setup(
        self,
        workflow_name: str,
        states: List[str], 
        transitions: List[Dict[str, Any]]
    ):
        """Add FSM transition methods to generated model."""
        # This would post-process the generated model to add @trigger decorated methods
        # For now, we'll rely on the template to set up the basic FSM
        pass


# Example transition definition
def observable_trigger(source, dest, **kwargs):
    """
    Enhanced trigger decorator that automatically adds OTEL instrumentation.
    """
    def decorator(func):
        # First apply the standard trigger decorator
        func = trigger(source, dest, **kwargs)(func)
        
        # Then wrap with span creation
        @functools.wraps(func)
        def wrapper(self, *args, **kwargs):
            if hasattr(self, '_tracer') and self._tracer:
                with self._tracer.start_as_current_span(
                    f"fsm.action.{func.__name__}",
                    attributes={
                        "fsm.action": func.__name__,
                        "fsm.source": source,
                        "fsm.dest": dest
                    }
                ) as span:
                    try:
                        result = func(self, *args, **kwargs)
                        span.set_status(Status(StatusCode.OK))
                        return result
                    except Exception as e:
                        span.set_status(
                            Status(StatusCode.ERROR, str(e))
                        )
                        span.record_exception(e)
                        raise
            else:
                return func(self, *args, **kwargs)
                
        return wrapper
    return decorator