"""
thesis_weaver_templates.py
───────────────────────────────────────────────────────────────────────────────
WeaverForge Template System for SwarmSH Thesis
• Custom Jinja2 templates for code generation from semantic conventions
• Generates Rust, Python, and TypeScript from thesis spans
• Demonstrates the complete span → code transformation
"""

from __future__ import annotations
from pathlib import Path
from typing import Dict, List, Optional
from pydantic import BaseModel, Field
from textwrap import dedent


# ─────────────────────────────────────────────────────────────────────────────
# 1. Template Models
# ─────────────────────────────────────────────────────────────────────────────

class WeaverTemplate(BaseModel):
    """Base class for WeaverForge templates"""
    name: str = Field(..., description="Template name")
    description: str = Field(..., description="Template description")
    file_extension: str = Field(..., description="Output file extension")
    
    def render(self, context: Dict) -> str:
        """Render the template with given context"""
        raise NotImplementedError


class RustSpanTemplate(WeaverTemplate):
    """Rust template for generating span implementations"""
    name: str = "rust_spans"
    description: str = "Generate Rust span implementations from semantic conventions"
    file_extension: str = "rs"
    
    def render(self, context: Dict) -> str:
        """Render Rust code for spans"""
        template = dedent('''
        // Generated by WeaverForge from SwarmSH thesis semantic conventions
        // DO NOT EDIT - This file is auto-generated
        
        use opentelemetry::{
            global,
            trace::{Span, SpanKind, StatusCode, TraceContextExt, Tracer},
            Context, KeyValue,
        };
        use std::time::Instant;
        
        /// SwarmSH Thesis Spans
        /// {{ group.brief }}
        pub mod {{ group.id|replace(".", "_") }} {
            use super::*;
            
            {% for attribute in group.attributes %}
            /// {{ attribute.brief }}
            pub const {{ attribute.id|upper }}: &str = "{{ group.prefix }}.{{ attribute.id }}";
            {% endfor %}
            
            /// Span builder for {{ group.id }}
            pub struct SpanBuilder {
                tracer: Box<dyn Tracer + Send + Sync>,
                {% for attribute in group.attributes %}
                {{ attribute.id }}: Option<{{ attribute.type|rust_type }}>,
                {% endfor %}
            }
            
            impl SpanBuilder {
                pub fn new(tracer: Box<dyn Tracer + Send + Sync>) -> Self {
                    Self {
                        tracer,
                        {% for attribute in group.attributes %}
                        {{ attribute.id }}: None,
                        {% endfor %}
                    }
                }
                
                {% for attribute in group.attributes %}
                /// Set {{ attribute.brief }}
                pub fn with_{{ attribute.id }}(mut self, value: {{ attribute.type|rust_type }}) -> Self {
                    self.{{ attribute.id }} = Some(value);
                    self
                }
                {% endfor %}
                
                /// Start the span
                pub fn start(self, name: &str) -> impl Span {
                    let mut span = self.tracer.span_builder(name)
                        .with_kind(SpanKind::Internal)
                        .start(&self.tracer);
                    
                    {% for attribute in group.attributes %}
                    if let Some(value) = self.{{ attribute.id }} {
                        span.set_attribute(KeyValue::new({{ attribute.id|upper }}, value));
                    }
                    {% endfor %}
                    
                    span
                }
            }
            
            {% for attribute in group.attributes %}
            /// Emit {{ attribute.id }} span
            pub fn emit_{{ attribute.id }}(tracer: &dyn Tracer) {
                let _span = tracer
                    .span_builder("{{ group.prefix }}.{{ attribute.id }}")
                    .with_attributes(vec![
                        KeyValue::new("brief", "{{ attribute.brief }}"),
                        KeyValue::new({{ attribute.id|upper }}, true),
                    ])
                    .start(tracer);
            }
            {% endfor %}
        }
        
        /// Auto-TRIZ feedback loop integration
        pub mod feedback_loop {
            use super::*;
            
            #[derive(Debug, Clone)]
            pub enum FeedbackPhase {
                Perception,
                Resolution,
                Generation,
                Realisation,
                Validation,
            }
            
            pub async fn run_feedback_iteration<T: Tracer>(tracer: &T) -> Result<(), Box<dyn std::error::Error>> {
                let span = tracer
                    .span_builder("swarmsh.feedback_loop.iteration")
                    .with_kind(SpanKind::Internal)
                    .start(tracer);
                
                let _guard = Context::current().with_span(span);
                
                // Phase 1: Perception
                {
                    let _span = tracer
                        .span_builder("swarmsh.feedback_loop.perception")
                        .start(tracer);
                    
                    // Collect telemetry
                    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                }
                
                // Continue with other phases...
                
                Ok(())
            }
        }
        ''').strip()
        
        # Simple template rendering (would use Jinja2 in production)
        rendered = template
        for key, value in context.items():
            rendered = rendered.replace(f"{{{{ {key} }}}}", str(value))
            
        # Handle filters
        rendered = rendered.replace("|replace(\".\", \"_\")", "")
        rendered = rendered.replace("|upper", "")
        rendered = rendered.replace("|rust_type", "")
        
        return rendered


class PythonSpanTemplate(WeaverTemplate):
    """Python template for generating span implementations"""
    name: str = "python_spans"
    description: str = "Generate Python span implementations from semantic conventions"
    file_extension: str = "py"
    
    def render(self, context: Dict) -> str:
        """Render Python code for spans"""
        template = dedent('''
        """
        Generated by WeaverForge from SwarmSH thesis semantic conventions
        DO NOT EDIT - This file is auto-generated
        """
        
        from typing import Optional, Any, Dict, ContextManager
        from contextlib import contextmanager
        from opentelemetry import trace
        from opentelemetry.trace import Status, StatusCode
        
        
        class {{ group.id|title|replace(".", "") }}Spans:
            """{{ group.brief }}"""
            
            {% for attribute in group.attributes %}
            {{ attribute.id|upper }} = "{{ group.prefix }}.{{ attribute.id }}"
            {% endfor %}
            
            def __init__(self, tracer: trace.Tracer):
                self.tracer = tracer
            
            {% for attribute in group.attributes %}
            @contextmanager
            def {{ attribute.id }}(self, **kwargs) -> ContextManager[trace.Span]:
                """
                {{ attribute.brief }}
                
                Args:
                    **kwargs: Additional span attributes
                """
                with self.tracer.start_as_current_span(
                    "{{ group.prefix }}.{{ attribute.id }}",
                    attributes={
                        "brief": "{{ attribute.brief }}",
                        self.{{ attribute.id|upper }}: True,
                        **kwargs
                    }
                ) as span:
                    yield span
            {% endfor %}
            
            def emit_all_thesis_spans(self):
                """Emit all thesis spans for demonstration"""
                {% for attribute in group.attributes %}
                with self.{{ attribute.id }}():
                    pass
                {% endfor %}
        
        
        class FeedbackLoop:
            """Auto-TRIZ feedback loop implementation"""
            
            def __init__(self, tracer: trace.Tracer):
                self.tracer = tracer
                self.thesis_spans = {{ group.id|title|replace(".", "") }}Spans(tracer)
            
            @contextmanager
            def perception_phase(self) -> ContextManager[trace.Span]:
                """Telemetry perception phase"""
                with self.tracer.start_as_current_span(
                    "swarmsh.feedback_loop.perception"
                ) as span:
                    span.set_attribute("phase", "perception")
                    yield span
            
            @contextmanager
            def resolution_phase(self) -> ContextManager[trace.Span]:
                """LLM resolution phase"""
                with self.tracer.start_as_current_span(
                    "swarmsh.feedback_loop.resolution"
                ) as span:
                    span.set_attribute("phase", "resolution")
                    yield span
            
            @contextmanager
            def generation_phase(self) -> ContextManager[trace.Span]:
                """WeaverForge generation phase"""
                with self.tracer.start_as_current_span(
                    "swarmsh.feedback_loop.generation"
                ) as span:
                    span.set_attribute("phase", "generation")
                    yield span
            
            async def run_iteration(self) -> Dict[str, Any]:
                """Run one complete feedback loop iteration"""
                with self.tracer.start_as_current_span(
                    "swarmsh.feedback_loop.iteration"
                ) as iteration_span:
                    
                    # Perception
                    with self.perception_phase() as span:
                        # Collect and analyze traces
                        contradictions = self._detect_contradictions()
                        span.set_attribute("contradictions_found", len(contradictions))
                    
                    # Resolution
                    with self.resolution_phase() as span:
                        # LLM proposes fixes
                        proposals = self._generate_proposals(contradictions)
                        span.set_attribute("proposals_generated", len(proposals))
                    
                    # Generation
                    with self.generation_phase() as span:
                        # Update semantic conventions and regenerate
                        updated = self._apply_proposals(proposals)
                        span.set_attribute("conventions_updated", updated)
                    
                    return {
                        "contradictions": len(contradictions),
                        "proposals": len(proposals),
                        "updated": updated
                    }
            
            def _detect_contradictions(self) -> list:
                """Detect contradictions in traces"""
                # Implementation would analyze actual traces
                return []
            
            def _generate_proposals(self, contradictions: list) -> list:
                """Generate resolution proposals"""
                # Implementation would use LLM
                return []
            
            def _apply_proposals(self, proposals: list) -> bool:
                """Apply proposals to semantic conventions"""
                # Implementation would update YAML and trigger WeaverForge
                return False
        ''').strip()
        
        # Simple template rendering
        rendered = template
        for key, value in context.items():
            rendered = rendered.replace(f"{{{{ {key} }}}}", str(value))
            
        # Handle filters
        rendered = rendered.replace("|title", "")
        rendered = rendered.replace("|replace(\".\", \"\")", "")
        rendered = rendered.replace("|upper", "")
        
        return rendered


class TypeScriptSpanTemplate(WeaverTemplate):
    """TypeScript template for generating span implementations"""
    name: str = "typescript_spans"
    description: str = "Generate TypeScript span implementations from semantic conventions"
    file_extension: str = "ts"
    
    def render(self, context: Dict) -> str:
        """Render TypeScript code for spans"""
        template = dedent('''
        /**
         * Generated by WeaverForge from SwarmSH thesis semantic conventions
         * DO NOT EDIT - This file is auto-generated
         */
        
        import { trace, Span, SpanKind, SpanStatusCode, Context } from '@opentelemetry/api';
        
        /**
         * {{ group.brief }}
         */
        export namespace {{ group.id|replace(".", "_") }} {
            {% for attribute in group.attributes %}
            export const {{ attribute.id|upper }} = '{{ group.prefix }}.{{ attribute.id }}';
            {% endfor %}
            
            export interface SpanOptions {
                {% for attribute in group.attributes %}
                {{ attribute.id }}?: {{ attribute.type|ts_type }};
                {% endfor %}
            }
            
            export class SpanBuilder {
                constructor(private tracer: trace.Tracer) {}
                
                {% for attribute in group.attributes %}
                /**
                 * {{ attribute.brief }}
                 */
                emit{{ attribute.id|title }}(options?: Partial<SpanOptions>): Span {
                    return this.tracer.startSpan('{{ group.prefix }}.{{ attribute.id }}', {
                        kind: SpanKind.INTERNAL,
                        attributes: {
                            brief: '{{ attribute.brief }}',
                            [{{ attribute.id|upper }}]: true,
                            ...options
                        }
                    });
                }
                {% endfor %}
                
                /**
                 * Emit all thesis spans
                 */
                emitAll(): void {
                    {% for attribute in group.attributes %}
                    this.emit{{ attribute.id|title }}().end();
                    {% endfor %}
                }
            }
        }
        
        /**
         * Auto-TRIZ Feedback Loop
         */
        export class FeedbackLoop {
            private readonly spans: {{ group.id|replace(".", "_") }}.SpanBuilder;
            
            constructor(private tracer: trace.Tracer) {
                this.spans = new {{ group.id|replace(".", "_") }}.SpanBuilder(tracer);
            }
            
            async runIteration(): Promise<FeedbackResult> {
                const iterationSpan = this.tracer.startSpan('swarmsh.feedback_loop.iteration');
                
                try {
                    // Perception phase
                    const perceptionSpan = this.tracer.startSpan('swarmsh.feedback_loop.perception', {
                        parent: iterationSpan
                    });
                    const contradictions = await this.detectContradictions();
                    perceptionSpan.setAttribute('contradictions_found', contradictions.length);
                    perceptionSpan.end();
                    
                    // Resolution phase
                    const resolutionSpan = this.tracer.startSpan('swarmsh.feedback_loop.resolution', {
                        parent: iterationSpan
                    });
                    const proposals = await this.generateProposals(contradictions);
                    resolutionSpan.setAttribute('proposals_generated', proposals.length);
                    resolutionSpan.end();
                    
                    // Generation phase
                    const generationSpan = this.tracer.startSpan('swarmsh.feedback_loop.generation', {
                        parent: iterationSpan
                    });
                    const updated = await this.applyProposals(proposals);
                    generationSpan.setAttribute('conventions_updated', updated);
                    generationSpan.end();
                    
                    return {
                        contradictions: contradictions.length,
                        proposals: proposals.length,
                        updated
                    };
                } finally {
                    iterationSpan.end();
                }
            }
            
            private async detectContradictions(): Promise<Contradiction[]> {
                // Implementation would analyze actual traces
                return [];
            }
            
            private async generateProposals(contradictions: Contradiction[]): Promise<Proposal[]> {
                // Implementation would use LLM
                return [];
            }
            
            private async applyProposals(proposals: Proposal[]): Promise<boolean> {
                // Implementation would update YAML and trigger WeaverForge
                return false;
            }
        }
        
        interface FeedbackResult {
            contradictions: number;
            proposals: number;
            updated: boolean;
        }
        
        interface Contradiction {
            type: string;
            severity: number;
            description: string;
        }
        
        interface Proposal {
            contradiction: Contradiction;
            resolution: string;
        }
        ''').strip()
        
        # Simple template rendering
        rendered = template
        for key, value in context.items():
            rendered = rendered.replace(f"{{{{ {key} }}}}", str(value))
            
        # Handle filters
        rendered = rendered.replace("|replace(\".\", \"_\")", "")
        rendered = rendered.replace("|upper", "")
        rendered = rendered.replace("|title", "")
        rendered = rendered.replace("|ts_type", "")
        
        return rendered


# ─────────────────────────────────────────────────────────────────────────────
# 2. Template Manager
# ─────────────────────────────────────────────────────────────────────────────

class WeaverTemplateManager(BaseModel):
    """Manages WeaverForge templates for code generation"""
    
    output_dir: Path = Field(..., description="Output directory for templates")
    templates: List[WeaverTemplate] = Field(
        default_factory=lambda: [
            RustSpanTemplate(),
            PythonSpanTemplate(),
            TypeScriptSpanTemplate()
        ]
    )
    
    def save_templates(self):
        """Save all templates to the output directory"""
        templates_dir = self.output_dir / "templates"
        templates_dir.mkdir(parents=True, exist_ok=True)
        
        for template in self.templates:
            # Save template file
            template_path = templates_dir / f"{template.name}.j2"
            
            # Create a simplified Jinja2 template
            jinja_template = self._convert_to_jinja2(template)
            template_path.write_text(jinja_template)
            
            print(f"✅ Saved template: {template_path}")
    
    def _convert_to_jinja2(self, template: WeaverTemplate) -> str:
        """Convert our template to actual Jinja2 format"""
        # For demonstration, we'll create a simple mapping
        # In production, this would be more sophisticated
        
        if isinstance(template, RustSpanTemplate):
            return RUST_JINJA2_TEMPLATE
        elif isinstance(template, PythonSpanTemplate):
            return PYTHON_JINJA2_TEMPLATE
        elif isinstance(template, TypeScriptSpanTemplate):
            return TYPESCRIPT_JINJA2_TEMPLATE
        else:
            return ""
    
    def generate_code(self, semantic_convention: Dict) -> Dict[str, str]:
        """Generate code for all templates"""
        generated = {}
        
        for template in self.templates:
            code = template.render(semantic_convention)
            filename = f"thesis_spans.{template.file_extension}"
            
            # Save generated code
            output_path = self.output_dir / "generated" / filename
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(code)
            
            generated[template.name] = str(output_path)
            print(f"✅ Generated: {output_path}")
        
        return generated


# ─────────────────────────────────────────────────────────────────────────────
# 3. Actual Jinja2 Templates (simplified)
# ─────────────────────────────────────────────────────────────────────────────

RUST_JINJA2_TEMPLATE = '''
{%- import 'macros.j2' as macros -%}
// Generated from {{ group.id }} semantic conventions
// {{ group.brief }}

use opentelemetry::{trace::Tracer, KeyValue};

{% for attribute in group.attributes %}
pub const {{ attribute.id | screaming_snake_case }}: &str = "{{ group.prefix }}.{{ attribute.id }}";
{% endfor %}

pub fn emit_thesis_spans(tracer: &dyn Tracer) {
    {% for attribute in group.attributes %}
    let span_{{ loop.index }} = tracer
        .span_builder("{{ group.prefix }}.{{ attribute.id }}")
        .with_attributes(vec![
            KeyValue::new("brief", "{{ attribute.brief }}"),
        ])
        .start(tracer);
    span_{{ loop.index }}.end();
    
    {% endfor %}
}
'''

PYTHON_JINJA2_TEMPLATE = '''
"""Generated from {{ group.id }} semantic conventions"""

from opentelemetry import trace

class {{ group.id | pascal_case }}Spans:
    """{{ group.brief }}"""
    
    {% for attribute in group.attributes %}
    {{ attribute.id | screaming_snake_case }} = "{{ group.prefix }}.{{ attribute.id }}"
    {% endfor %}
'''

TYPESCRIPT_JINJA2_TEMPLATE = '''
// Generated from {{ group.id }} semantic conventions
// {{ group.brief }}

import { Tracer } from '@opentelemetry/api';

{% for attribute in group.attributes %}
export const {{ attribute.id | screaming_snake_case }} = '{{ group.prefix }}.{{ attribute.id }}';
{% endfor %}
'''


# ─────────────────────────────────────────────────────────────────────────────
# 4. Demo
# ─────────────────────────────────────────────────────────────────────────────

def demo_weaver_templates():
    """Demonstrate WeaverForge template generation"""
    
    # Example semantic convention
    semconv = {
        "group": {
            "id": "swarmsh.thesis",
            "prefix": "swarmsh.thesis",
            "brief": "SwarmSH thesis claims as telemetry",
            "attributes": [
                {
                    "id": "telemetry_as_system",
                    "type": "boolean",
                    "brief": "Telemetry is the system, not an add-on."
                },
                {
                    "id": "span_drives_code",
                    "type": "boolean",
                    "brief": "Spans generate code & CLI."
                },
                {
                    "id": "trace_to_prompt_emergence",
                    "type": "boolean",
                    "brief": "Traces → LLM prompts (emergent)."
                }
            ]
        }
    }
    
    # Create template manager
    output_dir = Path("./weaver_output")
    manager = WeaverTemplateManager(output_dir=output_dir)
    
    print("🔧 WeaverForge Template Demo")
    print("="*60)
    
    # Save templates
    print("\n📝 Saving templates...")
    manager.save_templates()
    
    # Generate code
    print("\n⚙️  Generating code...")
    generated = manager.generate_code(semconv)
    
    print("\n✨ Generation complete!")
    print("\nGenerated files:")
    for name, path in generated.items():
        print(f"  - {name}: {path}")
    
    # Show sample of generated Rust code
    rust_path = Path(generated["rust_spans"])
    if rust_path.exists():
        print("\n📄 Sample Rust code:")
        print("-"*60)
        print(rust_path.read_text()[:500] + "...")


if __name__ == "__main__":
    demo_weaver_templates()