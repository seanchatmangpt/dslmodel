"""
Autonomous_evolution_loop - Auto-generated from semantic convention
Generated by WeaverEngine - DO NOT EDIT MANUALLY
"""

from typing import Optional, List, Literal, Dict, Any
from pydantic import Field
from opentelemetry import trace
from dslmodel import DSLModel


class Autonomous_evolution_scheduler(DSLModel):
    """Autonomous evolution cron scheduler"""
    
    scheduler_id: str = Field(
...,
        description="Unique identifier for the scheduler instance"
, examples=['scheduler-001', 'darwin-cron', 'evolution-daemon']    )
    schedule_interval_minutes: int = Field(
...,
        description="Interval between evolution cycles in minutes"
    )
    scheduler_state: str = Field(
...,
        description="Current state of the scheduler"
,
        examples=['starting', 'running', 'paused', 'stopping', 'error']
    )
    total_cycles_completed: Optional[int] = Field(
        None,
        description="Total number of evolution cycles completed"
    )
    uptime_minutes: Optional[int] = Field(
        None,
        description="Scheduler uptime in minutes"
    )
    meaningful_work_threshold: Optional[float] = Field(
        None,
        description="Minimum fitness improvement to consider work meaningful"
    )
    resource_limits: Optional[str] = Field(
        None,
        description="JSON string of resource limits for evolution"
    )
    last_meaningful_work_time: Optional[int] = Field(
        None,
        description="Timestamp of last meaningful work completion"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("autonomous.evolution.scheduler") as span:
            if self.scheduler_id is not None:
                span.set_attribute("autonomous.evolution.scheduler.scheduler_id", self.scheduler_id)
            if self.schedule_interval_minutes is not None:
                span.set_attribute("autonomous.evolution.scheduler.schedule_interval_minutes", self.schedule_interval_minutes)
            if self.scheduler_state is not None:
                span.set_attribute("autonomous.evolution.scheduler.scheduler_state", self.scheduler_state)
            if self.total_cycles_completed is not None:
                span.set_attribute("autonomous.evolution.scheduler.total_cycles_completed", self.total_cycles_completed)
            if self.uptime_minutes is not None:
                span.set_attribute("autonomous.evolution.scheduler.uptime_minutes", self.uptime_minutes)
            if self.meaningful_work_threshold is not None:
                span.set_attribute("autonomous.evolution.scheduler.meaningful_work_threshold", self.meaningful_work_threshold)
            if self.resource_limits is not None:
                span.set_attribute("autonomous.evolution.scheduler.resource_limits", self.resource_limits)
            if self.last_meaningful_work_time is not None:
                span.set_attribute("autonomous.evolution.scheduler.last_meaningful_work_time", self.last_meaningful_work_time)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Autonomous_evolution_cycle(DSLModel):
    """Single autonomous evolution cycle execution"""
    
    cycle_id: str = Field(
...,
        description="Unique identifier for this evolution cycle"
    )
    scheduler_id: str = Field(
...,
        description="Parent scheduler that initiated this cycle"
    )
    cycle_number: int = Field(
...,
        description="Sequential cycle number since scheduler start"
    )
    selected_strategy: str = Field(
...,
        description="Evolution strategy selected for this cycle"
, examples=['performance', 'security', 'quality', 'features', 'architecture']    )
    cycle_duration_ms: Optional[int] = Field(
        None,
        description="Total duration of the evolution cycle"
    )
    experiments_created: Optional[int] = Field(
        None,
        description="Number of experiments created in this cycle"
    )
    fitness_improvement: Optional[float] = Field(
        None,
        description="Fitness improvement achieved in this cycle"
    )
    meaningful_work_achieved: bool = Field(
...,
        description="Whether this cycle achieved meaningful work"
    )
    resource_usage: Optional[str] = Field(
        None,
        description="JSON string of resource usage during cycle"
    )
    next_cycle_recommendation: Optional[str] = Field(
        None,
        description="Recommended strategy for next cycle"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("autonomous.evolution.cycle") as span:
            if self.cycle_id is not None:
                span.set_attribute("autonomous.evolution.cycle.cycle_id", self.cycle_id)
            if self.scheduler_id is not None:
                span.set_attribute("autonomous.evolution.cycle.scheduler_id", self.scheduler_id)
            if self.cycle_number is not None:
                span.set_attribute("autonomous.evolution.cycle.cycle_number", self.cycle_number)
            if self.selected_strategy is not None:
                span.set_attribute("autonomous.evolution.cycle.selected_strategy", self.selected_strategy)
            if self.cycle_duration_ms is not None:
                span.set_attribute("autonomous.evolution.cycle.cycle_duration_ms", self.cycle_duration_ms)
            if self.experiments_created is not None:
                span.set_attribute("autonomous.evolution.cycle.experiments_created", self.experiments_created)
            if self.fitness_improvement is not None:
                span.set_attribute("autonomous.evolution.cycle.fitness_improvement", self.fitness_improvement)
            if self.meaningful_work_achieved is not None:
                span.set_attribute("autonomous.evolution.cycle.meaningful_work_achieved", self.meaningful_work_achieved)
            if self.resource_usage is not None:
                span.set_attribute("autonomous.evolution.cycle.resource_usage", self.resource_usage)
            if self.next_cycle_recommendation is not None:
                span.set_attribute("autonomous.evolution.cycle.next_cycle_recommendation", self.next_cycle_recommendation)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Autonomous_evolution_strategy_selection(DSLModel):
    """Intelligent strategy selection for evolution cycle"""
    
    cycle_id: str = Field(
...,
        description="Evolution cycle requesting strategy selection"
    )
    telemetry_analysis_duration_ms: Optional[int] = Field(
        None,
        description="Time spent analyzing telemetry for strategy selection"
    )
    available_strategies: str = Field(
...,
        description="JSON array of available evolution strategies"
    )
    strategy_scores: Optional[str] = Field(
        None,
        description="JSON object of strategy fitness scores"
    )
    selected_strategy: str = Field(
...,
        description="Strategy selected by AI analysis"
    )
    selection_confidence: Optional[float] = Field(
        None,
        description="Confidence score for strategy selection (0-1)"
    )
    historical_performance: Optional[str] = Field(
        None,
        description="JSON object of historical strategy performance"
    )
    system_needs_priority: Optional[str] = Field(
        None,
        description="Current highest priority system need",
        examples=['performance', 'reliability', 'security', 'maintainability']
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("autonomous.evolution.strategy_selection") as span:
            if self.cycle_id is not None:
                span.set_attribute("autonomous.evolution.strategy_selection.cycle_id", self.cycle_id)
            if self.telemetry_analysis_duration_ms is not None:
                span.set_attribute("autonomous.evolution.strategy_selection.telemetry_analysis_duration_ms", self.telemetry_analysis_duration_ms)
            if self.available_strategies is not None:
                span.set_attribute("autonomous.evolution.strategy_selection.available_strategies", self.available_strategies)
            if self.strategy_scores is not None:
                span.set_attribute("autonomous.evolution.strategy_selection.strategy_scores", self.strategy_scores)
            if self.selected_strategy is not None:
                span.set_attribute("autonomous.evolution.strategy_selection.selected_strategy", self.selected_strategy)
            if self.selection_confidence is not None:
                span.set_attribute("autonomous.evolution.strategy_selection.selection_confidence", self.selection_confidence)
            if self.historical_performance is not None:
                span.set_attribute("autonomous.evolution.strategy_selection.historical_performance", self.historical_performance)
            if self.system_needs_priority is not None:
                span.set_attribute("autonomous.evolution.strategy_selection.system_needs_priority", self.system_needs_priority)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Autonomous_evolution_meaningful_work(DSLModel):
    """Assessment of meaningful work completion"""
    
    cycle_id: str = Field(
...,
        description="Evolution cycle being assessed"
    )
    assessment_type: str = Field(
...,
        description="Type of meaningful work assessment"
, examples=['fitness_threshold', 'impact_analysis', 'user_value', 'technical_debt']    )
    baseline_fitness: float = Field(
        ...,
        description="Baseline fitness before evolution cycle"
    )
    achieved_fitness: float = Field(
        ...,
        description="Fitness achieved after evolution cycle"
    )
    improvement_percentage: float = Field(
        ...,
        description="Percentage improvement in fitness"
    )
    meaningful_threshold: float = Field(
        ...,
        description="Threshold for considering work meaningful"
    )
    work_classification: str = Field(
...,
        description="Classification of work meaningfulness"
, examples=['highly_meaningful', 'meaningful', 'marginal', 'insignificant']    )
    impact_areas: Optional[str] = Field(
        None,
        description="JSON array of areas impacted by the work"
    )
    deployment_recommended: bool = Field(
...,
        description="Whether deployment is recommended"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("autonomous.evolution.meaningful_work") as span:
            if self.cycle_id is not None:
                span.set_attribute("autonomous.evolution.meaningful_work.cycle_id", self.cycle_id)
            if self.assessment_type is not None:
                span.set_attribute("autonomous.evolution.meaningful_work.assessment_type", self.assessment_type)
            if self.baseline_fitness is not None:
                span.set_attribute("autonomous.evolution.meaningful_work.baseline_fitness", self.baseline_fitness)
            if self.achieved_fitness is not None:
                span.set_attribute("autonomous.evolution.meaningful_work.achieved_fitness", self.achieved_fitness)
            if self.improvement_percentage is not None:
                span.set_attribute("autonomous.evolution.meaningful_work.improvement_percentage", self.improvement_percentage)
            if self.meaningful_threshold is not None:
                span.set_attribute("autonomous.evolution.meaningful_work.meaningful_threshold", self.meaningful_threshold)
            if self.work_classification is not None:
                span.set_attribute("autonomous.evolution.meaningful_work.work_classification", self.work_classification)
            if self.impact_areas is not None:
                span.set_attribute("autonomous.evolution.meaningful_work.impact_areas", self.impact_areas)
            if self.deployment_recommended is not None:
                span.set_attribute("autonomous.evolution.meaningful_work.deployment_recommended", self.deployment_recommended)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Autonomous_evolution_resource_management(DSLModel):
    """Resource management for autonomous evolution"""
    
    scheduler_id: str = Field(
...,
        description="Scheduler managing resources"
    )
    resource_type: str = Field(
...,
        description="Type of resource being managed"
, examples=['worktrees', 'memory', 'cpu', 'disk', 'network']    )
    current_usage: float = Field(
        ...,
        description="Current resource usage (percentage or absolute)"
    )
    usage_limit: float = Field(
        ...,
        description="Resource usage limit"
    )
    resource_action: str = Field(
...,
        description="Resource management action taken"
, examples=['allocate', 'cleanup', 'throttle', 'alert', 'emergency_stop']    )
    resources_cleaned: Optional[int] = Field(
        None,
        description="Number of resources cleaned up"
    )
    cleanup_success: Optional[bool] = Field(
        None,
        description="Whether resource cleanup was successful"
    )
    resource_health_score: Optional[float] = Field(
        None,
        description="Overall resource health score (0-1)"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("autonomous.evolution.resource_management") as span:
            if self.scheduler_id is not None:
                span.set_attribute("autonomous.evolution.resource_management.scheduler_id", self.scheduler_id)
            if self.resource_type is not None:
                span.set_attribute("autonomous.evolution.resource_management.resource_type", self.resource_type)
            if self.current_usage is not None:
                span.set_attribute("autonomous.evolution.resource_management.current_usage", self.current_usage)
            if self.usage_limit is not None:
                span.set_attribute("autonomous.evolution.resource_management.usage_limit", self.usage_limit)
            if self.resource_action is not None:
                span.set_attribute("autonomous.evolution.resource_management.resource_action", self.resource_action)
            if self.resources_cleaned is not None:
                span.set_attribute("autonomous.evolution.resource_management.resources_cleaned", self.resources_cleaned)
            if self.cleanup_success is not None:
                span.set_attribute("autonomous.evolution.resource_management.cleanup_success", self.cleanup_success)
            if self.resource_health_score is not None:
                span.set_attribute("autonomous.evolution.resource_management.resource_health_score", self.resource_health_score)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class Autonomous_evolution_error_recovery(DSLModel):
    """Error handling and recovery for autonomous evolution"""
    
    scheduler_id: str = Field(
...,
        description="Scheduler experiencing the error"
    )
    error_type: str = Field(
...,
        description="Type of error encountered"
, examples=['git_operation', 'resource_exhaustion', 'strategy_failure', 'network_timeout']    )
    error_severity: str = Field(
...,
        description="Severity level of the error"
, examples=['low', 'medium', 'high', 'critical']    )
    error_message: Optional[str] = Field(
        None,
        description="Detailed error message"
    )
    recovery_action: str = Field(
...,
        description="Recovery action taken"
, examples=['retry', 'skip_cycle', 'switch_strategy', 'emergency_stop', 'cleanup_and_restart']    )
    recovery_success: bool = Field(
...,
        description="Whether recovery was successful"
    )
    retry_count: Optional[int] = Field(
        None,
        description="Number of retry attempts made"
    )
    recovery_duration_ms: Optional[int] = Field(
        None,
        description="Time taken for recovery"
    )
    system_stability_impact: Optional[str] = Field(
        None,
        description="Impact on overall system stability",
        examples=['none', 'minimal', 'moderate', 'significant']
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("autonomous.evolution.error_recovery") as span:
            if self.scheduler_id is not None:
                span.set_attribute("autonomous.evolution.error_recovery.scheduler_id", self.scheduler_id)
            if self.error_type is not None:
                span.set_attribute("autonomous.evolution.error_recovery.error_type", self.error_type)
            if self.error_severity is not None:
                span.set_attribute("autonomous.evolution.error_recovery.error_severity", self.error_severity)
            if self.error_message is not None:
                span.set_attribute("autonomous.evolution.error_recovery.error_message", self.error_message)
            if self.recovery_action is not None:
                span.set_attribute("autonomous.evolution.error_recovery.recovery_action", self.recovery_action)
            if self.recovery_success is not None:
                span.set_attribute("autonomous.evolution.error_recovery.recovery_success", self.recovery_success)
            if self.retry_count is not None:
                span.set_attribute("autonomous.evolution.error_recovery.retry_count", self.retry_count)
            if self.recovery_duration_ms is not None:
                span.set_attribute("autonomous.evolution.error_recovery.recovery_duration_ms", self.recovery_duration_ms)
            if self.system_stability_impact is not None:
                span.set_attribute("autonomous.evolution.error_recovery.system_stability_impact", self.system_stability_impact)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
