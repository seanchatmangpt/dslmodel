"""
User_workflow - Auto-generated from semantic convention
Generated by WeaverEngine - DO NOT EDIT MANUALLY
"""

from typing import Optional, List, Literal, Dict, Any
from pydantic import Field
from opentelemetry import trace
from dslmodel import DSLModel


class User_authentication(DSLModel):
    """User authentication operations"""
    
    operation: str = Field(
...,
        description="Type of authentication operation"
, examples=['login', 'logout', 'password_reset', 'mfa_verify']    )
    user_id: str = Field(
...,
        description="Unique user identifier"
, examples=['user-123', 'admin-456']    )
    session_id: Optional[str] = None = Field(
None,
        description="User session identifier"
    )
    auth_method: Optional[str] = None = Field(
None,
        description="Authentication method used"
, examples=['password', 'oauth', 'sso', 'mfa']    )
    success: bool = Field(
...,
        description="Whether authentication was successful"
    )
    duration_ms: Optional[int] = None = Field(
None,
        description="Authentication duration in milliseconds"
    )
    error_code: Optional[str] = None = Field(
None,
        description="Error code if authentication failed"
, examples=['invalid_credentials', 'account_locked', 'token_expired']    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("user.authentication") as span:
            if self.operation is not None:
                span.set_attribute("app.user.operation", self.operation)
            if self.user_id is not None:
                span.set_attribute("app.user.user_id", self.user_id)
            if self.session_id is not None:
                span.set_attribute("app.user.session_id", self.session_id)
            if self.auth_method is not None:
                span.set_attribute("app.user.auth_method", self.auth_method)
            if self.success is not None:
                span.set_attribute("app.user.success", self.success)
            if self.duration_ms is not None:
                span.set_attribute("app.user.duration_ms", self.duration_ms)
            if self.error_code is not None:
                span.set_attribute("app.user.error_code", self.error_code)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class User_profile_management(DSLModel):
    """User profile management operations"""
    
    operation: str = Field(
...,
        description="Type of profile operation"
, examples=['create', 'update', 'delete', 'view']    )
    user_id: str = Field(
...,
        description="Target user identifier"
    )
    fields_updated: Optional[str] = None = Field(
None,
        description="List of profile fields that were updated"
    )
    data_size_bytes: Optional[int] = None = Field(
None,
        description="Size of profile data in bytes"
    )
    validation_errors: Optional[str] = None = Field(
None,
        description="List of validation errors encountered"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("user.profile_management") as span:
            if self.operation is not None:
                span.set_attribute("app.user.operation", self.operation)
            if self.user_id is not None:
                span.set_attribute("app.user.user_id", self.user_id)
            if self.fields_updated is not None:
                span.set_attribute("app.user.fields_updated", self.fields_updated)
            if self.data_size_bytes is not None:
                span.set_attribute("app.user.data_size_bytes", self.data_size_bytes)
            if self.validation_errors is not None:
                span.set_attribute("app.user.validation_errors", self.validation_errors)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
class User_preference_sync(DSLModel):
    """User preference synchronization"""
    
    user_id: str = Field(
...,
        description="User identifier for preference sync"
    )
    sync_direction: str = Field(
...,
        description="Direction of synchronization"
, examples=['upload', 'download', 'bidirectional']    )
    preferences_count: Optional[int] = None = Field(
None,
        description="Number of preferences synchronized"
    )
    sync_success: bool = Field(
...,
        description="Whether sync completed successfully"
    )
    conflicts_resolved: Optional[int] = None = Field(
None,
        description="Number of conflicts resolved during sync"
    )
    
    def emit_telemetry(self) -> str:
        """Emit telemetry span for this model"""
        tracer = trace.get_tracer(__name__)
        
        with tracer.start_as_current_span("user.preference_sync") as span:
            if self.user_id is not None:
                span.set_attribute("app.user.user_id", self.user_id)
            if self.sync_direction is not None:
                span.set_attribute("app.user.sync_direction", self.sync_direction)
            if self.preferences_count is not None:
                span.set_attribute("app.user.preferences_count", self.preferences_count)
            if self.sync_success is not None:
                span.set_attribute("app.user.sync_success", self.sync_success)
            if self.conflicts_resolved is not None:
                span.set_attribute("app.user.conflicts_resolved", self.conflicts_resolved)
            
            return span.get_span_context().trace_id.to_bytes(16, 'big').hex()
        
