---
to: src/dslmodel/ecosystems/<%= fileName %>.py
---
"""
<%= featureClass %> Ecosystem - Complete 360¬∞ Integration

This module demonstrates a complete ecosystem implementation featuring:
- Multiple coordinated SwarmAgents
- OpenTelemetry semantic conventions
- Multi-step workflows with rollback
- CLI commands with Rich output
- Comprehensive test coverage
- Real-time monitoring

Generated by: Weaver Hygen Templates (360¬∞ Ecosystem)
"""

import time
import json
import asyncio
from typing import Dict, Any, List, Optional, Union
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass
from contextlib import asynccontextmanager

# Core imports
from pydantic import BaseModel, Field
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

# SwarmAgent ecosystem imports
from dslmodel.agents.swarm.swarm_agent import SwarmAgent
from dslmodel.agents.swarm.swarm_models import SpanData, NextCommand
from dslmodel.mixins.fsm_mixin import trigger

# OpenTelemetry imports
try:
    from opentelemetry import trace, metrics
    from opentelemetry.sdk.trace import TracerProvider
    from opentelemetry.sdk.resources import Resource
    OTEL_AVAILABLE = True
except ImportError:
    OTEL_AVAILABLE = False

console = Console()


@dataclass
class EcosystemConfig:
    """Configuration for the <%= featureClass %> ecosystem."""
    
    feature_name: str = "<%= featureClass %>"
    domain: str = "<%= domain %>"
    telemetry_file: Path = Path("~/s2s/agent_coordination/telemetry_spans.jsonl").expanduser()
    
    # Agent configuration
    agents: List[str] = None
    states: List[str] = None
    workflows: List[str] = None
    
    # Performance configuration
    span_batch_size: int = 100
    processing_timeout: float = 30.0
    coordination_delay: float = 0.5
    
    def __post_init__(self):
        if self.agents is None:
            self.agents = <%= JSON.stringify(agents) %>
        if self.states is None:
            self.states = <%= JSON.stringify(states) %>
        if self.workflows is None:
            self.workflows = <%= JSON.stringify(workflows) %>


class <%= featureClass %>EcosystemBase(BaseModel):
    """Base class for <%= featureClass %> ecosystem components."""
    
    config: EcosystemConfig = Field(default_factory=EcosystemConfig)
    ecosystem_id: str = Field(default_factory=lambda: f"<%= featureLower %>_{int(time.time() * 1000)}")
    start_time: datetime = Field(default_factory=datetime.now)
    
    # Telemetry tracking
    spans_emitted: int = Field(default=0)
    commands_processed: int = Field(default=0)
    errors_encountered: int = Field(default=0)
    
    class Config:
        arbitrary_types_allowed = True


# Generated Agents
<% agents.forEach(function(agent, index) { %>class <%= agent.charAt(0).toUpperCase() + agent.slice(1) %>Agent(SwarmAgent, <%= featureClass %>EcosystemBase):
    """<%= agent.charAt(0).toUpperCase() + agent.slice(1) %> agent for <%= featureClass %> ecosystem."""
    
    # Agent configuration
    AGENT_TYPE = "<%= agent.toLowerCase() %>"
    LISTEN_FILTER = "swarmsh.<%= prefix %>.<%= agent.toLowerCase() %>"
    
    # State machine
    name: str = Field(default="<%= agent.charAt(0).toUpperCase() + agent.slice(1) %>Agent")
    states: List[str] = Field(default=<%= JSON.stringify(states) %>)
    initial_state: str = Field(default="<%= states[0] %>")
    
    # Agent-specific metrics
    <%= agent.toLowerCase() %>_operations: int = Field(default=0)
    <%= agent.toLowerCase() %>_success_rate: float = Field(default=0.0)
    
    def __init__(self, **data):
        super().__init__(**data)
        
        # Set up trigger mapping
        self.TRIGGER_MAPPING = {
<% states.slice(0, 3).forEach(function(state) { %>            "<%= state.toLowerCase() %>": self.handle_<%= state.toLowerCase() %>,
<% }); %>        }
    
<% states.slice(0, 3).forEach(function(state) { %>    @trigger("<%= state.toLowerCase() %>")
    def handle_<%= state.toLowerCase() %>(self, span: SpanData) -> Optional[NextCommand]:
        """Handle <%= state.toLowerCase() %> trigger for <%= agent %> agent."""
        self.<%= agent.toLowerCase() %>_operations += 1
        self.commands_processed += 1
        
        console.print(f"[blue]<%= agent.charAt(0).toUpperCase() + agent.slice(1) %>Agent:[/blue] Processing <%= state.toLowerCase() %> - {span.span_id[:8]}...")
        
        # Simulate processing
        time.sleep(self.config.coordination_delay)
        
        # Generate next command for coordination
<% if (index < agents.length - 1) { %>        return NextCommand(
            name=f"swarmsh.<%= prefix %>.<%= agents[index + 1] %>.{self.get_next_action()}",
            attributes={
                "previous_agent": self.AGENT_TYPE,
                "coordination_step": self.<%= agent.toLowerCase() %>_operations,
                "ecosystem_id": self.ecosystem_id
            }
        )<% } else { %>        # Last agent in chain - complete workflow
        return NextCommand(
            name=f"swarmsh.<%= prefix %>.workflow.complete",
            attributes={
                "final_agent": self.AGENT_TYPE,
                "ecosystem_id": self.ecosystem_id,
                "total_operations": self.<%= agent.toLowerCase() %>_operations
            }
        )<% } %>
    
<% }); %>    def get_next_action(self) -> str:
        """Determine next action based on current state."""
        action_map = {
<% states.slice(0, 3).forEach(function(state, idx) { %>            "<%= states[idx] %>": "<%= states[(idx + 1) % states.length].toLowerCase() %>",
<% }); %>        }
        return action_map.get(self.state, "<%= states[0].toLowerCase() %>")
    
    def get_agent_metrics(self) -> Dict[str, Any]:
        """Get agent-specific metrics."""
        total_ops = max(self.<%= agent.toLowerCase() %>_operations, 1)
        success_ops = total_ops - self.errors_encountered
        
        return {
            "agent_type": self.AGENT_TYPE,
            "operations": self.<%= agent.toLowerCase() %>_operations,
            "success_rate": (success_ops / total_ops) * 100,
            "current_state": self.state,
            "ecosystem_id": self.ecosystem_id
        }

<% }); %>

class <%= featureClass %>WorkflowOrchestrator(<%= featureClass %>EcosystemBase):
    """Workflow orchestrator for <%= featureClass %> ecosystem."""
    
    def __init__(self, **data):
        super().__init__(**data)
        
        # Initialize agents
        self.agents = {
<% agents.forEach(function(agent) { %>            "<%= agent.toLowerCase() %>": <%= agent.charAt(0).toUpperCase() + agent.slice(1) %>Agent(ecosystem_id=self.ecosystem_id),
<% }); %>        }
        
        # Workflow state
        self.active_workflows: Dict[str, Dict[str, Any]] = {}
        self.completed_workflows: List[Dict[str, Any]] = []
    
    async def execute_workflow(self, workflow_name: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute a complete workflow with all agents.
        
        Args:
            workflow_name: Name of the workflow to execute
            params: Optional workflow parameters
            
        Returns:
            Workflow execution results
        """
        workflow_id = f"{workflow_name}_{int(time.time() * 1000)}"
        
        console.print(Panel.fit(
            f"[bold blue]üîÑ Executing {workflow_name.title()} Workflow[/bold blue]\n"
            f"[dim]ID: {workflow_id}[/dim]",
            border_style="blue"
        ))
        
        # Initialize workflow tracking
        workflow_context = {
            "id": workflow_id,
            "name": workflow_name,
            "start_time": datetime.now(),
            "params": params or {},
            "steps_completed": 0,
            "agents_involved": [],
            "spans_generated": []
        }
        
        self.active_workflows[workflow_id] = workflow_context
        
        try:
            # Execute workflow steps
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=console
            ) as progress:
                
                task = progress.add_task("Executing workflow...", total=len(self.config.agents))
                
                # Start with first agent
                current_span = self._create_initial_span(workflow_name, workflow_id, params)
                
                for agent_name in self.config.agents:
                    agent = self.agents[agent_name]
                    
                    # Process span with agent
                    result = agent.forward(current_span)
                    
                    # Track progress
                    workflow_context["steps_completed"] += 1
                    workflow_context["agents_involved"].append(agent_name)
                    workflow_context["spans_generated"].append(current_span.span_id)
                    
                    progress.update(task, advance=1, description=f"Processing with {agent_name} agent...")
                    
                    # Prepare next span if result provided
                    if result:
                        current_span = self._create_coordination_span(result, workflow_id)
                    
                    # Simulate async processing
                    await asyncio.sleep(self.config.coordination_delay)
            
            # Complete workflow
            workflow_context["end_time"] = datetime.now()
            workflow_context["duration"] = (workflow_context["end_time"] - workflow_context["start_time"]).total_seconds()
            workflow_context["status"] = "completed"
            
            # Move to completed
            self.completed_workflows.append(workflow_context)
            del self.active_workflows[workflow_id]
            
            console.print(f"[green]‚úÖ Workflow {workflow_name} completed in {workflow_context['duration']:.2f}s[/green]")
            
            return workflow_context
            
        except Exception as e:
            workflow_context["status"] = "failed"
            workflow_context["error"] = str(e)
            console.print(f"[red]‚ùå Workflow {workflow_name} failed: {e}[/red]")
            raise
    
    def _create_initial_span(self, workflow_name: str, workflow_id: str, params: Dict[str, Any]) -> SpanData:
        """Create initial span for workflow."""
        return SpanData(
            name=f"swarmsh.<%= prefix %>.{workflow_name}.start",
            trace_id=workflow_id,
            span_id=f"span_{int(time.time() * 1e9)}",
            timestamp=time.time(),
            attributes={
                "workflow.name": workflow_name,
                "workflow.id": workflow_id,
                "ecosystem.id": self.ecosystem_id,
                **params
            }
        )
    
    def _create_coordination_span(self, command: NextCommand, workflow_id: str) -> SpanData:
        """Create coordination span from NextCommand."""
        return SpanData(
            name=command.name,
            trace_id=workflow_id,
            span_id=f"span_{int(time.time() * 1e9)}",
            timestamp=time.time(),
            attributes=command.attributes or {}
        )
    
    def get_workflow_status(self) -> Dict[str, Any]:
        """Get current workflow status."""
        return {
            "active_workflows": len(self.active_workflows),
            "completed_workflows": len(self.completed_workflows),
            "total_agents": len(self.agents),
            "ecosystem_id": self.ecosystem_id,
            "uptime": (datetime.now() - self.start_time).total_seconds()
        }
    
    def generate_ecosystem_report(self) -> Dict[str, Any]:
        """Generate comprehensive ecosystem report."""
        agent_metrics = {
            name: agent.get_agent_metrics() 
            for name, agent in self.agents.items()
        }
        
        return {
            "ecosystem": {
                "feature": self.config.feature_name,
                "domain": self.config.domain,
                "id": self.ecosystem_id,
                "uptime": (datetime.now() - self.start_time).total_seconds()
            },
            "workflows": {
                "active": len(self.active_workflows),
                "completed": len(self.completed_workflows),
                "success_rate": self._calculate_success_rate()
            },
            "agents": agent_metrics,
            "performance": {
                "total_spans": self.spans_emitted,
                "total_commands": self.commands_processed,
                "error_rate": (self.errors_encountered / max(self.commands_processed, 1)) * 100
            }
        }
    
    def _calculate_success_rate(self) -> float:
        """Calculate overall workflow success rate."""
        if not self.completed_workflows:
            return 0.0
        
        successful = sum(1 for w in self.completed_workflows if w.get("status") == "completed")
        return (successful / len(self.completed_workflows)) * 100


class <%= featureClass %>EcosystemManager:
    """Main manager for the <%= featureClass %> ecosystem."""
    
    def __init__(self, config: Optional[EcosystemConfig] = None):
        self.config = config or EcosystemConfig()
        self.orchestrator = <%= featureClass %>WorkflowOrchestrator(config=self.config)
        self.console = Console()
        
        # Telemetry setup if available
        if OTEL_AVAILABLE:
            self._setup_telemetry()
    
    def _setup_telemetry(self):
        """Set up OpenTelemetry integration."""
        resource = Resource.create({
            "service.name": f"<%= featureLower %>_ecosystem",
            "service.version": "1.0.0",
            "ecosystem.feature": self.config.feature_name,
            "ecosystem.domain": self.config.domain
        })
        
        # Configure tracer
        tracer_provider = TracerProvider(resource=resource)
        trace.set_tracer_provider(tracer_provider)
        self.tracer = trace.get_tracer(__name__)
    
    async def run_complete_demo(self) -> Dict[str, Any]:
        """Run complete ecosystem demonstration."""
        self.console.print(Panel.fit(
            f"[bold green]üöÄ {self.config.feature_name} Ecosystem Demo[/bold green]\n"
            f"[dim]Domain: {self.config.domain}[/dim]\n"
            f"[dim]Agents: {', '.join(self.config.agents)}[/dim]",
            border_style="green"
        ))
        
        results = {}
        
        try:
            # Run all workflows
            for workflow_name in self.config.workflows:
                self.console.print(f"\n[blue]‚ñ∂ Starting {workflow_name} workflow...[/blue]")
                
                workflow_result = await self.orchestrator.execute_workflow(
                    workflow_name,
                    {"demo": True, "timestamp": datetime.now().isoformat()}
                )
                
                results[workflow_name] = workflow_result
            
            # Generate final report
            ecosystem_report = self.orchestrator.generate_ecosystem_report()
            results["ecosystem_report"] = ecosystem_report
            
            # Display summary
            self._display_demo_summary(results)
            
            return results
            
        except Exception as e:
            self.console.print(f"[red]‚ùå Demo failed: {e}[/red]")
            raise
    
    def _display_demo_summary(self, results: Dict[str, Any]):
        """Display demo summary with Rich formatting."""
        report = results["ecosystem_report"]
        
        # Create summary table
        table = Table(title=f"{self.config.feature_name} Ecosystem Summary")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="green")
        
        # Ecosystem metrics
        ecosystem = report["ecosystem"]
        table.add_row("Feature", ecosystem["feature"])
        table.add_row("Domain", ecosystem["domain"])
        table.add_row("Uptime", f"{ecosystem['uptime']:.2f}s")
        
        # Workflow metrics
        workflows = report["workflows"]
        table.add_row("Workflows Completed", str(workflows["completed"]))
        table.add_row("Success Rate", f"{workflows['success_rate']:.1f}%")
        
        # Performance metrics
        performance = report["performance"]
        table.add_row("Total Spans", str(performance["total_spans"]))
        table.add_row("Total Commands", str(performance["total_commands"]))
        table.add_row("Error Rate", f"{performance['error_rate']:.1f}%")
        
        self.console.print(table)
        
        # Agent status
        agents_table = Table(title="Agent Status")
        agents_table.add_column("Agent", style="blue")
        agents_table.add_column("Operations", style="yellow")
        agents_table.add_column("Success Rate", style="green")
        agents_table.add_column("State", style="magenta")
        
        for agent_name, metrics in report["agents"].items():
            agents_table.add_row(
                metrics["agent_type"],
                str(metrics["operations"]),
                f"{metrics['success_rate']:.1f}%",
                metrics["current_state"]
            )
        
        self.console.print(agents_table)


# Convenience functions
async def run_<%= featureLower %>_ecosystem_demo(config: Optional[EcosystemConfig] = None) -> Dict[str, Any]:
    """Run the complete <%= featureClass %> ecosystem demonstration.
    
    Args:
        config: Optional ecosystem configuration
        
    Returns:
        Demo results and ecosystem report
    """
    manager = <%= featureClass %>EcosystemManager(config)
    return await manager.run_complete_demo()


def create_<%= featureLower %>_config(**kwargs) -> EcosystemConfig:
    """Create <%= featureClass %> ecosystem configuration.
    
    Args:
        **kwargs: Configuration parameters
        
    Returns:
        Configured EcosystemConfig instance
    """
    return EcosystemConfig(**kwargs)


# Export main components
__all__ = [
    "EcosystemConfig",
    "<%= featureClass %>EcosystemBase",
<% agents.forEach(function(agent) { %>    "<%= agent.charAt(0).toUpperCase() + agent.slice(1) %>Agent",
<% }); %>    "<%= featureClass %>WorkflowOrchestrator",
    "<%= featureClass %>EcosystemManager",
    "run_<%= featureLower %>_ecosystem_demo",
    "create_<%= featureLower %>_config"
]


# Example usage
if __name__ == "__main__":
    async def main():
        """Run the ecosystem demo."""
        console.print("[bold blue]Starting <%= featureClass %> Ecosystem Demo...[/bold blue]")
        
        # Create custom configuration
        config = create_<%= featureLower %>_config(
            coordination_delay=0.3,  # Faster demo
            processing_timeout=15.0
        )
        
        # Run demo
        results = await run_<%= featureLower %>_ecosystem_demo(config)
        
        console.print("\n[green]‚úÖ Demo completed successfully![/green]")
        console.print(f"[dim]Results: {len(results)} workflows executed[/dim]")
    
    # Run async demo
    asyncio.run(main())